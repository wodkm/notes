# 模式杂谈

## 设计模式分类

|范围\目的|创建型模式|结构型模式|行为型模式|
| - | - | - | - |
|类模式|工厂方法|(类）适配器|模板方法、解释器|
|对象模式|单例<br>原型<br>抽象工厂<br>建造者|代理<br>(对象）适配器<br>桥接<br>装饰<br>外观<br>享元<br>组合|策略<br>命令<br>职责链<br>状态<br>观察者<br>中介者<br>迭代器<br>访问者<br>备忘录|

## 差异性的根本

设计模式的差异性来自于它们适用场景，或者说解决问题的初衷不同。有些设计模式的实现过程是相似的，至少部分相似，但最终尝试解决的问题是不同的

## 动态

当一种模式的实现需要通过修改代码来扩展其功能，主要是频繁地因业务逻辑而做出修改时，自然就会需要引入“动态”的概念。java里的动态多半与反射是有关的

## 执行顺序

执行顺序的实现基本有两种，一是代码编写时写定的顺序，另一种是找个数组类结构去维护需要按序执行的一系列操作，这种方式往往意味着顺序可调整

## 单例模式与享元模式

单例模式属于创建型模式，而享元模式属于结构型模式
享元模式解决的是减少大量小对象的内存开销，单例模式实现的是某个类的实例在程序中只需要一个
某种程度上享元模式算是单例模式的延申，有限的多例模式那种，因为它既不局限于单例，又控制了实例数量。享元模式更注重的是有限多个实例的复用，避免反复创建和销毁的同时又保持同时存在多个可用实例

## 工厂方法模式与抽象工厂模式

主要是抽象创建方法的个数差异，抽象工厂具有复数个且可增长的实例化方法

## 建造者模式与工厂模式

建造者模式唯一区别于工厂模式的是针对复杂对象的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式

## 单例模式与工厂模式混用

通常工厂类应以单例模式创建

## 代理模式与装饰器模式

使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象
个人倾向于将代理模式理解为使用生命周期对被代理对象进行包装，包括执行前后及前置判断

## 模板方法模式与策略模式

模板方法模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤
策略模式：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户
模板方法模式可以看作是一系列步骤的抽象，每个步骤的具体实现是可以不同的，策略模式侧重一组方法的选择

## 策略模式与命令模式

策略模式是通过不同的算法做同一件事情：例如排序
而命令模式则是通过不同的命令做不同的事情，常含有（关联）接收者

## 命令模式与备忘录模式混用

## 责任链模式

把责任和链分开理解，责任限定了每个节点的职能，每个节点仅处理自己职能内的任务，并不关注前后节点职能，处理结束或是未处理则直接向后传递
